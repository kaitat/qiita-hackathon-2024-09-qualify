// Code generated by sqlc-gen-ts-d1. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
//   sqlc-gen-ts-d1 v0.0.0-a@dfd4bfef4736967ca17cc23d18de20920fbd196998fe7aa191a205439d63fb58

import { D1Database, D1PreparedStatement, D1Result } from "@cloudflare/workers-types/experimental"

type Query<T> = {
  then(onFulfilled?: (value: T) => void, onRejected?: (reason?: any) => void): void;
  batch(): D1PreparedStatement;
}
const createConversationQuery = `-- name: createConversation :exec
INSERT INTO Conversations (id) VALUES (?1)`;

export type createConversationParams = {
  id: string;
};

export function createConversation(
  d1: D1Database,
  args: createConversationParams
): Query<D1Result> {
  const ps = d1
    .prepare(createConversationQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getConversationByIdQuery = `-- name: getConversationById :one
SELECT
    id, ask_count, created_at, updated_at
FROM
    Conversations
WHERE
    id = ?1`;

export type getConversationByIdParams = {
  id: string;
};

export type getConversationByIdRow = {
  id: string;
  askCount: number;
  createdAt: string;
  updatedAt: string;
};

type RawgetConversationByIdRow = {
  id: string;
  ask_count: number;
  created_at: string;
  updated_at: string;
};

export function getConversationById(
  d1: D1Database,
  args: getConversationByIdParams
): Query<getConversationByIdRow | null> {
  const ps = d1
    .prepare(getConversationByIdQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: getConversationByIdRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetConversationByIdRow | null>()
        .then((raw: RawgetConversationByIdRow | null) => raw ? {
          id: raw.id,
          askCount: raw.ask_count,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createMessageQuery = `-- name: createMessage :exec
INSERT INTO Messages (id, conversation_id, sender, message) VALUES (?1, ?2, ?3, ?4)`;

export type createMessageParams = {
  id: string;
  conversationId: string;
  sender: string;
  message: string;
};

export function createMessage(
  d1: D1Database,
  args: createMessageParams
): Query<D1Result> {
  const ps = d1
    .prepare(createMessageQuery)
    .bind(args.id, args.conversationId, args.sender, args.message);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const updateConversationAskCountQuery = `-- name: updateConversationAskCount :exec
UPDATE
    Conversations
SET
    ask_count = ?1
WHERE
    id = ?2`;

export type updateConversationAskCountParams = {
  askCount: number;
  id: string;
};

export function updateConversationAskCount(
  d1: D1Database,
  args: updateConversationAskCountParams
): Query<D1Result> {
  const ps = d1
    .prepare(updateConversationAskCountQuery)
    .bind(args.askCount, args.id);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getMessagesByConversationIdQuery = `-- name: getMessagesByConversationId :many
SELECT
    id, conversation_id, sender, message, send_at_unix_time, created_at, updated_at
FROM
    Messages
WHERE
    conversation_id = ?1
ORDER BY
    send_at_unix_time asc`;

export type getMessagesByConversationIdParams = {
  conversationId: string;
};

export type getMessagesByConversationIdRow = {
  id: string;
  conversationId: string;
  sender: string;
  message: string;
  sendAtUnixTime: number | null;
  createdAt: string;
  updatedAt: string;
};

type RawgetMessagesByConversationIdRow = {
  id: string;
  conversation_id: string;
  sender: string;
  message: string;
  send_at_unix_time: number | null;
  created_at: string;
  updated_at: string;
};

export function getMessagesByConversationId(
  d1: D1Database,
  args: getMessagesByConversationIdParams
): Query<D1Result<getMessagesByConversationIdRow>> {
  const ps = d1
    .prepare(getMessagesByConversationIdQuery)
    .bind(args.conversationId);
  return {
    then(onFulfilled?: (value: D1Result<getMessagesByConversationIdRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetMessagesByConversationIdRow>()
        .then((r: D1Result<RawgetMessagesByConversationIdRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetMessagesByConversationIdRow) => { return {
            id: raw.id,
            conversationId: raw.conversation_id,
            sender: raw.sender,
            message: raw.message,
            sendAtUnixTime: raw.send_at_unix_time,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getDocumentsQuery = `-- name: getDocuments :many
SELECT
    id, conversation_id, content, created_at, updated_at
FROM
    Documents
ORDER BY
    created_at DESC`;

export type getDocumentsRow = {
  id: string;
  conversationId: string;
  content: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetDocumentsRow = {
  id: string;
  conversation_id: string;
  content: string;
  created_at: string;
  updated_at: string;
};

export function getDocuments(
  d1: D1Database
): Query<D1Result<getDocumentsRow>> {
  const ps = d1
    .prepare(getDocumentsQuery);
  return {
    then(onFulfilled?: (value: D1Result<getDocumentsRow>) => void, onRejected?: (reason?: any) => void) {
      ps.all<RawgetDocumentsRow>()
        .then((r: D1Result<RawgetDocumentsRow>) => { return {
          ...r,
          results: r.results.map((raw: RawgetDocumentsRow) => { return {
            id: raw.id,
            conversationId: raw.conversation_id,
            content: raw.content,
            createdAt: raw.created_at,
            updatedAt: raw.updated_at,
          }}),
        }})
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const createDocumentQuery = `-- name: createDocument :exec
INSERT INTO Documents (id, conversation_id, content) VALUES (?1, ?2, ?3)`;

export type createDocumentParams = {
  id: string;
  conversationId: string;
  content: string;
};

export function createDocument(
  d1: D1Database,
  args: createDocumentParams
): Query<D1Result> {
  const ps = d1
    .prepare(createDocumentQuery)
    .bind(args.id, args.conversationId, args.content);
  return {
    then(onFulfilled?: (value: D1Result) => void, onRejected?: (reason?: any) => void) {
      ps.run()
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getDocumentByIdQuery = `-- name: getDocumentById :one
SELECT
    id, conversation_id, content, created_at, updated_at
FROM
    Documents
WHERE
    id = ?1`;

export type getDocumentByIdParams = {
  id: string;
};

export type getDocumentByIdRow = {
  id: string;
  conversationId: string;
  content: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetDocumentByIdRow = {
  id: string;
  conversation_id: string;
  content: string;
  created_at: string;
  updated_at: string;
};

export function getDocumentById(
  d1: D1Database,
  args: getDocumentByIdParams
): Query<getDocumentByIdRow | null> {
  const ps = d1
    .prepare(getDocumentByIdQuery)
    .bind(args.id);
  return {
    then(onFulfilled?: (value: getDocumentByIdRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetDocumentByIdRow | null>()
        .then((raw: RawgetDocumentByIdRow | null) => raw ? {
          id: raw.id,
          conversationId: raw.conversation_id,
          content: raw.content,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

const getDocumentByConversationIdQuery = `-- name: getDocumentByConversationId :one
SELECT
    id, conversation_id, content, created_at, updated_at
FROM
    Documents
WHERE
    conversation_id = ?1`;

export type getDocumentByConversationIdParams = {
  conversationId: string;
};

export type getDocumentByConversationIdRow = {
  id: string;
  conversationId: string;
  content: string;
  createdAt: string;
  updatedAt: string;
};

type RawgetDocumentByConversationIdRow = {
  id: string;
  conversation_id: string;
  content: string;
  created_at: string;
  updated_at: string;
};

export function getDocumentByConversationId(
  d1: D1Database,
  args: getDocumentByConversationIdParams
): Query<getDocumentByConversationIdRow | null> {
  const ps = d1
    .prepare(getDocumentByConversationIdQuery)
    .bind(args.conversationId);
  return {
    then(onFulfilled?: (value: getDocumentByConversationIdRow | null) => void, onRejected?: (reason?: any) => void) {
      ps.first<RawgetDocumentByConversationIdRow | null>()
        .then((raw: RawgetDocumentByConversationIdRow | null) => raw ? {
          id: raw.id,
          conversationId: raw.conversation_id,
          content: raw.content,
          createdAt: raw.created_at,
          updatedAt: raw.updated_at,
        } : null)
        .then(onFulfilled).catch(onRejected);
    },
    batch() { return ps; },
  }
}

